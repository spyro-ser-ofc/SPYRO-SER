(function(gt,k){typeof exports=="object"&&typeof module=="object"?module.exports=k():typeof define=="function"&&define.amd?define([],k):typeof exports=="object"?exports["image-q"]=k():gt["image-q"]=k()})(typeof globalThis!="undefined"?globalThis:typeof this!="undefined"?this:typeof global!="undefined"?global:typeof window!="undefined"?window:null,function(){return(()=>{var Ht={516:()=>{},563:()=>{}},gt={};function k(v){var T=gt[v];if(T!==void 0)return T.exports;var L=gt[v]={exports:{}};return Ht[v](L,L.exports,k),L.exports}(()=>{k.d=(v,T)=>{for(var L in T)k.o(T,L)&&!k.o(v,L)&&Object.defineProperty(v,L,{enumerable:!0,get:T[L]})}})(),(()=>{k.o=(v,T)=>Object.prototype.hasOwnProperty.call(v,T)})(),(()=>{k.r=v=>{typeof Symbol!="undefined"&&Symbol.toStringTag&&Object.defineProperty(v,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(v,"__esModule",{value:!0})}})();var At={};return(()=>{"use strict";k.r(At),k.d(At,{applyPalette:()=>ji,applyPaletteSync:()=>Wi,buildPalette:()=>Ui,buildPaletteSync:()=>Hi,constants:()=>T,conversion:()=>bt,distance:()=>Bt,image:()=>It,palette:()=>Pt,quality:()=>Et,utils:()=>Rt});var v={};k.r(v),k.d(v,{Y:()=>I,x:()=>vt,y:()=>Gt});var T={};k.r(T),k.d(T,{bt709:()=>v});var L={};k.r(L),k.d(L,{degrees2radians:()=>V,inRange0to255:()=>N,inRange0to255Rounded:()=>Q,intInRange:()=>xi,max3:()=>Wt,min3:()=>jt,stableSort:()=>qt});var bt={};k.r(bt),k.d(bt,{lab2rgb:()=>Pi,lab2xyz:()=>Ot,rgb2hsl:()=>Mt,rgb2lab:()=>ht,rgb2xyz:()=>Ut,xyz2lab:()=>Ft,xyz2rgb:()=>Vt});var Bt={};k.r(Bt),k.d(Bt,{AbstractDistanceCalculator:()=>J,AbstractEuclidean:()=>ft,AbstractManhattan:()=>xt,CIE94GraphicArts:()=>Jt,CIE94Textiles:()=>$t,CIEDE2000:()=>W,CMetric:()=>Yt,Euclidean:()=>Zt,EuclideanBT709:()=>Kt,EuclideanBT709NoAlpha:()=>ti,Manhattan:()=>ii,ManhattanBT709:()=>si,ManhattanNommyde:()=>ei,PNGQuant:()=>ai});var Rt={};k.r(Rt),k.d(Rt,{HueStatistics:()=>ri,Palette:()=>ot,Point:()=>q,PointContainer:()=>j,ProgressTracker:()=>O,arithmetic:()=>L});var Pt={};k.r(Pt),k.d(Pt,{AbstractPaletteQuantizer:()=>lt,ColorHistogram:()=>_t,NeuQuant:()=>b,NeuQuantFloat:()=>B,PaletteQuantizerYieldValue:()=>Ci.PaletteQuantizerYieldValue,RGBQuant:()=>li,WuColorCube:()=>oi,WuQuant:()=>at});var It={};k.r(It),k.d(It,{AbstractImageQuantizer:()=>wt,ErrorDiffusionArray:()=>F,ErrorDiffusionArrayKernel:()=>H,ErrorDiffusionRiemersma:()=>yt,ImageQuantizerYieldValue:()=>qi.ImageQuantizerYieldValue,NearestColor:()=>mi});var Et={};k.r(Et),k.d(Et,{ssim:()=>Li});/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */var I;(function(t){t[t.RED=.2126]="RED",t[t.GREEN=.7152]="GREEN",t[t.BLUE=.0722]="BLUE",t[t.WHITE=1]="WHITE"})(I||(I={}));var vt;(function(t){t[t.RED=.64]="RED",t[t.GREEN=.3]="GREEN",t[t.BLUE=.15]="BLUE",t[t.WHITE=.3127]="WHITE"})(vt||(vt={}));var Gt;(function(t){t[t.RED=.33]="RED",t[t.GREEN=.6]="GREEN",t[t.BLUE=.06]="BLUE",t[t.WHITE=.329]="WHITE"})(Gt||(Gt={}));/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */var fi=Math.pow,Fi=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */function Ct(t){return t>.04045?fi((t+.055)/1.055,2.4):t/12.92}function Ut(t,i,e){return t=Ct(t/255),i=Ct(i/255),e=Ct(e/255),{x:t*.4124+i*.3576+e*.1805,y:t*.2126+i*.7152+e*.0722,z:t*.0193+i*.1192+e*.9505}}function V(t){return t*(Math.PI/180)}function Wt(t,i,e){let s=t;return s<i&&(s=i),s<e&&(s=e),s}function jt(t,i,e){let s=t;return s>i&&(s=i),s>e&&(s=e),s}function xi(t,i,e){return t>e&&(t=e),t<i&&(t=i),t|0}function Q(t){return t=Math.round(t),t>255?t=255:t<0&&(t=0),t}function N(t){return t>255?t=255:t<0&&(t=0),t}function qt(t,i){const e=typeof t[0];let s;if(e==="number"||e==="string"){const a=Object.create(null);for(let n=0,r=t.length;n<r;n++){const h=t[n];a[h]||a[h]===0||(a[h]=n)}s=t.sort((n,r)=>i(n,r)||a[n]-a[r])}else{const a=t.slice(0);s=t.sort((n,r)=>i(n,r)||a.indexOf(n)-a.indexOf(r))}return s}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */function Mt(t,i,e){const s=jt(t,i,e),a=Wt(t,i,e),n=a-s,r=(s+a)/510;let h=0;r>0&&r<1&&(h=n/(r<.5?a+s:510-a-s));let l=0;return n>0&&(a===t?l=(i-e)/n:a===i?l=2+(e-t)/n:l=4+(t-i)/n,l*=60,l<0&&(l+=360)),{h:l,s:h,l:r}}var wi=Math.pow,Oi=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */const yi=.95047,Si=1,ki=1.08883;function Nt(t){return t>.008856?wi(t,1/3):7.787*t+16/116}function Ft(t,i,e){if(t=Nt(t/yi),i=Nt(i/Si),e=Nt(e/ki),116*i-16<0)throw new Error("xxx");return{L:Math.max(0,116*i-16),a:500*(t-i),b:200*(i-e)}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */function ht(t,i,e){const s=Ut(t,i,e);return Ft(s.x,s.y,s.z)}var zi=Math.pow,Vi=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */const Ai=.95047,bi=1,Bi=1.08883;function Dt(t){return t>.206893034?zi(t,3):(t-16/116)/7.787}function Ot(t,i,e){const s=(t+16)/116,a=i/500+s,n=s-e/200;return{x:Ai*Dt(a),y:bi*Dt(s),z:Bi*Dt(n)}}var Ri=Math.pow,Xi=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */function Tt(t){return t>.0031308?1.055*Ri(t,1/2.4)-.055:12.92*t}function Vt(t,i,e){const s=Tt(t*3.2406+i*-1.5372+e*-.4986),a=Tt(t*-.9689+i*1.8758+e*.0415),n=Tt(t*.0557+i*-.204+e*1.057);return{r:Q(s*255),g:Q(a*255),b:Q(n*255)}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */function Pi(t,i,e){const s=Ot(t,i,e);return Vt(s.x,s.y,s.z)}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 *//**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */class J{constructor(){this._setDefaults(),this.setWhitePoint(255,255,255,255)}setWhitePoint(i,e,s,a){this._whitePoint={r:i>0?255/i:0,g:e>0?255/e:0,b:s>0?255/s:0,a:a>0?255/a:0},this._maxDistance=this.calculateRaw(i,e,s,a,0,0,0,0)}calculateNormalized(i,e){return this.calculateRaw(i.r,i.g,i.b,i.a,e.r,e.g,e.b,e.a)/this._maxDistance}}var pt=Math.pow,$i=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */class Xt extends J{calculateRaw(i,e,s,a,n,r,h,l){const _=ht(N(i*this._whitePoint.r),N(e*this._whitePoint.g),N(s*this._whitePoint.b)),m=ht(N(n*this._whitePoint.r),N(r*this._whitePoint.g),N(h*this._whitePoint.b)),o=_.L-m.L,u=_.a-m.a,d=_.b-m.b,M=Math.sqrt(_.a*_.a+_.b*_.b),g=Math.sqrt(m.a*m.a+m.b*m.b),c=M-g;let S=u*u+d*d-c*c;S=S<0?0:Math.sqrt(S);const x=(l-a)*this._whitePoint.a*this._kA;return Math.sqrt(pt(o/this._Kl,2)+pt(c/(1+this._K1*M),2)+pt(S/(1+this._K2*M),2)+pt(x,2))}}class $t extends Xt{_setDefaults(){this._Kl=2,this._K1=.048,this._K2=.014,this._kA=.25*50/255}}class Jt extends Xt{_setDefaults(){this._Kl=1,this._K1=.045,this._K2=.015,this._kA=.25*100/255}}var X=Math.pow,Ji=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */const A=class extends J{_setDefaults(){}static _calculatehp(t,i){const e=Math.atan2(t,i);return e>=0?e:e+A._deg360InRad}static _calculateRT(t,i){const e=X(i,7),s=2*Math.sqrt(e/(e+A._pow25to7)),a=A._deg30InRad*Math.exp(-X((t-A._deg275InRad)/A._deg25InRad,2));return-Math.sin(2*a)*s}static _calculateT(t){return 1-.17*Math.cos(t-A._deg30InRad)+.24*Math.cos(t*2)+.32*Math.cos(t*3+A._deg6InRad)-.2*Math.cos(t*4-A._deg63InRad)}static _calculate_ahp(t,i,e,s){const a=e+s;return t===0?a:i<=A._deg180InRad?a/2:a<A._deg360InRad?(a+A._deg360InRad)/2:(a-A._deg360InRad)/2}static _calculate_dHp(t,i,e,s){let a;return t===0?a=0:i<=A._deg180InRad?a=e-s:e<=s?a=e-s+A._deg360InRad:a=e-s-A._deg360InRad,2*Math.sqrt(t)*Math.sin(a/2)}calculateRaw(t,i,e,s,a,n,r,h){const l=ht(N(t*this._whitePoint.r),N(i*this._whitePoint.g),N(e*this._whitePoint.b)),_=ht(N(a*this._whitePoint.r),N(n*this._whitePoint.g),N(r*this._whitePoint.b)),m=(h-s)*this._whitePoint.a*A._kA,o=this.calculateRawInLab(l,_);return Math.sqrt(o+m*m)}calculateRawInLab(t,i){const e=t.L,s=t.a,a=t.b,n=i.L,r=i.a,h=i.b,l=Math.sqrt(s*s+a*a),_=Math.sqrt(r*r+h*h),m=X((l+_)/2,7),o=.5*(1-Math.sqrt(m/(m+A._pow25to7))),u=(1+o)*s,d=(1+o)*r,M=Math.sqrt(u*u+a*a),g=Math.sqrt(d*d+h*h),c=M*g,S=A._calculatehp(a,u),x=A._calculatehp(h,d),z=Math.abs(S-x),R=n-e,P=g-M,U=A._calculate_dHp(c,z,x,S),p=A._calculate_ahp(c,z,S,x),ut=A._calculateT(p),Y=(M+g)/2,zt=X((e+n)/2-50,2),Qt=1+.015*zt/Math.sqrt(20+zt),$=1+.045*Y,ct=1+.015*ut*Y,dt=A._calculateRT(p,Y),rt=R/Qt,Z=P/$,pi=U/ct;return X(rt,2)+X(Z,2)+X(pi,2)+dt*Z*pi}};let W=A;W._kA=.25*100/255,W._pow25to7=X(25,7),W._deg360InRad=V(360),W._deg180InRad=V(180),W._deg30InRad=V(30),W._deg6InRad=V(6),W._deg63InRad=V(63),W._deg275InRad=V(275),W._deg25InRad=V(25);/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */class Yt extends J{calculateRaw(i,e,s,a,n,r,h,l){const _=(i+n)/2*this._whitePoint.r,m=(i-n)*this._whitePoint.r,o=(e-r)*this._whitePoint.g,u=(s-h)*this._whitePoint.b,d=((512+_)*m*m>>8)+4*o*o+((767-_)*u*u>>8),M=(l-a)*this._whitePoint.a;return Math.sqrt(d+M*M)}_setDefaults(){}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */class ft extends J{calculateRaw(i,e,s,a,n,r,h,l){const _=n-i,m=r-e,o=h-s,u=l-a;return Math.sqrt(this._kR*_*_+this._kG*m*m+this._kB*o*o+this._kA*u*u)}}class Zt extends ft{_setDefaults(){this._kR=1,this._kG=1,this._kB=1,this._kA=1}}class Kt extends ft{_setDefaults(){this._kR=I.RED,this._kG=I.GREEN,this._kB=I.BLUE,this._kA=1}}class ti extends ft{_setDefaults(){this._kR=I.RED,this._kG=I.GREEN,this._kB=I.BLUE,this._kA=0}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */class xt extends J{calculateRaw(i,e,s,a,n,r,h,l){let _=n-i,m=r-e,o=h-s,u=l-a;return _<0&&(_=0-_),m<0&&(m=0-m),o<0&&(o=0-o),u<0&&(u=0-u),this._kR*_+this._kG*m+this._kB*o+this._kA*u}}class ii extends xt{_setDefaults(){this._kR=1,this._kG=1,this._kB=1,this._kA=1}}class ei extends xt{_setDefaults(){this._kR=.4984,this._kG=.8625,this._kB=.2979,this._kA=1}}class si extends xt{_setDefaults(){this._kR=I.RED,this._kG=I.GREEN,this._kB=I.BLUE,this._kA=1}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */class ai extends J{calculateRaw(i,e,s,a,n,r,h,l){const _=(l-a)*this._whitePoint.a;return this._colordifferenceCh(i*this._whitePoint.r,n*this._whitePoint.r,_)+this._colordifferenceCh(e*this._whitePoint.g,r*this._whitePoint.g,_)+this._colordifferenceCh(s*this._whitePoint.b,h*this._whitePoint.b,_)}_colordifferenceCh(i,e,s){const a=i-e,n=a+s;return a*a+n*n}_setDefaults(){}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 *//**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */class lt{quantizeSync(){for(const i of this.quantize())if(i.palette)return i.palette;throw new Error("unreachable")}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */class q{static createByQuadruplet(i){const e=new q;return e.r=i[0]|0,e.g=i[1]|0,e.b=i[2]|0,e.a=i[3]|0,e._loadUINT32(),e._loadQuadruplet(),e}static createByRGBA(i,e,s,a){const n=new q;return n.r=i|0,n.g=e|0,n.b=s|0,n.a=a|0,n._loadUINT32(),n._loadQuadruplet(),n}static createByUint32(i){const e=new q;return e.uint32=i>>>0,e._loadRGBA(),e._loadQuadruplet(),e}constructor(){this.uint32=-1>>>0,this.r=this.g=this.b=this.a=0,this.rgba=new Array(4),this.rgba[0]=0,this.rgba[1]=0,this.rgba[2]=0,this.rgba[3]=0}from(i){this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this.uint32=i.uint32,this.rgba[0]=i.r,this.rgba[1]=i.g,this.rgba[2]=i.b,this.rgba[3]=i.a}getLuminosity(i){let e=this.r,s=this.g,a=this.b;return i&&(e=Math.min(255,255-this.a+this.a*e/255),s=Math.min(255,255-this.a+this.a*s/255),a=Math.min(255,255-this.a+this.a*a/255)),e*I.RED+s*I.GREEN+a*I.BLUE}_loadUINT32(){this.uint32=(this.a<<24|this.b<<16|this.g<<8|this.r)>>>0}_loadRGBA(){this.r=this.uint32&255,this.g=this.uint32>>>8&255,this.b=this.uint32>>>16&255,this.a=this.uint32>>>24&255}_loadQuadruplet(){this.rgba[0]=this.r,this.rgba[1]=this.g,this.rgba[2]=this.b,this.rgba[3]=this.a}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */class j{constructor(){this._width=0,this._height=0,this._pointArray=[]}getWidth(){return this._width}getHeight(){return this._height}setWidth(i){this._width=i}setHeight(i){this._height=i}getPointArray(){return this._pointArray}clone(){const i=new j;i._width=this._width,i._height=this._height;for(let e=0,s=this._pointArray.length;e<s;e++)i._pointArray[e]=q.createByUint32(this._pointArray[e].uint32|0);return i}toUint32Array(){const i=this._pointArray.length,e=new Uint32Array(i);for(let s=0;s<i;s++)e[s]=this._pointArray[s].uint32;return e}toUint8Array(){return new Uint8Array(this.toUint32Array().buffer)}static fromHTMLImageElement(i){const e=i.naturalWidth,s=i.naturalHeight,a=document.createElement("canvas");return a.width=e,a.height=s,a.getContext("2d").drawImage(i,0,0,e,s,0,0,e,s),j.fromHTMLCanvasElement(a)}static fromHTMLCanvasElement(i){const e=i.width,s=i.height,n=i.getContext("2d").getImageData(0,0,e,s);return j.fromImageData(n)}static fromImageData(i){const e=i.width,s=i.height;return j.fromUint8Array(i.data,e,s)}static fromUint8Array(i,e,s){switch(Object.prototype.toString.call(i)){case"[object Uint8ClampedArray]":case"[object Uint8Array]":break;default:i=new Uint8Array(i)}const a=new Uint32Array(i.buffer);return j.fromUint32Array(a,e,s)}static fromUint32Array(i,e,s){const a=new j;a._width=e,a._height=s;for(let n=0,r=i.length;n<r;n++)a._pointArray[n]=q.createByUint32(i[n]|0);return a}static fromBuffer(i,e,s){const a=new Uint32Array(i.buffer,i.byteOffset,i.byteLength/Uint32Array.BYTES_PER_ELEMENT);return j.fromUint32Array(a,e,s)}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */const ni=10;function Lt(t,i){const s=360/i,a=s/2;for(let n=1,r=s-a;n<i;n++,r+=s)if(t>=r&&t<r+s)return n;return 0}class ot{constructor(){this._pointArray=[],this._i32idx={},this._pointContainer=new j,this._pointContainer.setHeight(1),this._pointArray=this._pointContainer.getPointArray()}add(i){this._pointArray.push(i),this._pointContainer.setWidth(this._pointArray.length)}has(i){for(let e=this._pointArray.length-1;e>=0;e--)if(i.uint32===this._pointArray[e].uint32)return!0;return!1}getNearestColor(i,e){return this._pointArray[this._getNearestIndex(i,e)|0]}getPointContainer(){return this._pointContainer}_nearestPointFromCache(i){return typeof this._i32idx[i]=="number"?this._i32idx[i]:-1}_getNearestIndex(i,e){let s=this._nearestPointFromCache(""+e.uint32);if(s>=0)return s;let a=Number.MAX_VALUE;s=0;for(let n=0,r=this._pointArray.length;n<r;n++){const h=this._pointArray[n],l=i.calculateRaw(e.r,e.g,e.b,e.a,h.r,h.g,h.b,h.a);l<a&&(a=l,s=n)}return this._i32idx[e.uint32]=s,s}sort(){this._i32idx={},this._pointArray.sort((i,e)=>{const s=Mt(i.r,i.g,i.b),a=Mt(e.r,e.g,e.b),n=i.r===i.g&&i.g===i.b?0:1+Lt(s.h,ni),h=(e.r===e.g&&e.g===e.b?0:1+Lt(a.h,ni))-n;if(h)return-h;const l=i.getLuminosity(!0),_=e.getLuminosity(!0);if(_-l!=0)return _-l;const m=(a.s*100|0)-(s.s*100|0);return m?-m:0})}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */class Ii{constructor(){this.num=0,this.cols=[]}}class ri{constructor(i,e){this._numGroups=i,this._minCols=e,this._stats=[];for(let s=0;s<=i;s++)this._stats[s]=new Ii;this._groupsFull=0}check(i){this._groupsFull===this._numGroups+1&&(this.check=()=>{});const e=i&255,s=i>>>8&255,a=i>>>16&255,n=e===s&&s===a?0:1+Lt(Mt(e,s,a).h,this._numGroups),r=this._stats[n],h=this._minCols;r.num++,!(r.num>h)&&(r.num===h&&this._groupsFull++,r.num<=h&&this._stats[n].cols.push(i))}injectIntoDictionary(i){for(let e=0;e<=this._numGroups;e++)this._stats[e].num<=this._minCols&&this._stats[e].cols.forEach(s=>{i[s]?i[s]++:i[s]=1})}injectIntoArray(i){for(let e=0;e<=this._numGroups;e++)this._stats[e].num<=this._minCols&&this._stats[e].cols.forEach(s=>{i.indexOf(s)===-1&&i.push(s)})}}const hi=class{constructor(t,i){this._range=t,this._progressRange=i,this._step=Math.max(1,this._range/(hi.steps+1)|0),this._last=-this._step,this.progress=0}shouldNotify(t){return t-this._last>=this._step?(this._last=t,this.progress=Math.min(this._progressRange*this._last/this._range,this._progressRange),!0):!1}};let O=hi;O.steps=100;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 *//**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */const G=3;class Ei{constructor(i){this.r=this.g=this.b=this.a=i}toPoint(){return q.createByRGBA(this.r>>G,this.g>>G,this.b>>G,this.a>>G)}subtract(i,e,s,a){this.r-=i|0,this.g-=e|0,this.b-=s|0,this.a-=a|0}}const w=class extends lt{constructor(t,i=256){super();this._distance=t,this._pointArray=[],this._sampleFactor=1,this._networkSize=i,this._distance.setWhitePoint(255<<G,255<<G,255<<G,255<<G)}sample(t){this._pointArray=this._pointArray.concat(t.getPointArray())}*quantize(){this._init(),yield*this._learn(),yield{palette:this._buildPalette(),progress:100}}_init(){this._freq=[],this._bias=[],this._radPower=[],this._network=[];for(let t=0;t<this._networkSize;t++)this._network[t]=new Ei((t<<G+8)/this._networkSize|0),this._freq[t]=w._initialBias/this._networkSize|0,this._bias[t]=0}*_learn(){let t=this._sampleFactor;const i=this._pointArray.length;i<w._minpicturebytes&&(t=1);const e=30+(t-1)/3|0,s=i/t|0;let a=s/w._nCycles|0,n=w._initAlpha,r=(this._networkSize>>3)*w._radiusBias,h=r>>w._radiusBiasShift;h<=1&&(h=0);for(let m=0;m<h;m++)this._radPower[m]=n*((h*h-m*m)*w._radBias/(h*h))>>>0;let l;i<w._minpicturebytes?l=1:i%w._prime1!=0?l=w._prime1:i%w._prime2!=0?l=w._prime2:i%w._prime3!=0?l=w._prime3:l=w._prime4;const _=new O(s,99);for(let m=0,o=0;m<s;){_.shouldNotify(m)&&(yield{progress:_.progress});const u=this._pointArray[o],d=u.b<<G,M=u.g<<G,g=u.r<<G,c=u.a<<G,S=this._contest(d,M,g,c);if(this._alterSingle(n,S,d,M,g,c),h!==0&&this._alterNeighbour(h,S,d,M,g,c),o+=l,o>=i&&(o-=i),m++,a===0&&(a=1),m%a==0){n-=n/e|0,r-=r/w._radiusDecrease|0,h=r>>w._radiusBiasShift,h<=1&&(h=0);for(let x=0;x<h;x++)this._radPower[x]=n*((h*h-x*x)*w._radBias/(h*h))>>>0}}}_buildPalette(){const t=new ot;return this._network.forEach(i=>{t.add(i.toPoint())}),t.sort(),t}_alterNeighbour(t,i,e,s,a,n){let r=i-t;r<-1&&(r=-1);let h=i+t;h>this._networkSize&&(h=this._networkSize);let l=i+1,_=i-1,m=1;for(;l<h||_>r;){const o=this._radPower[m++]/w._alphaRadBias;if(l<h){const u=this._network[l++];u.subtract(o*(u.r-a),o*(u.g-s),o*(u.b-e),o*(u.a-n))}if(_>r){const u=this._network[_--];u.subtract(o*(u.r-a),o*(u.g-s),o*(u.b-e),o*(u.a-n))}}}_alterSingle(t,i,e,s,a,n){t/=w._initAlpha;const r=this._network[i];r.subtract(t*(r.r-a),t*(r.g-s),t*(r.b-e),t*(r.a-n))}_contest(t,i,e,s){const a=255*4<<G;let n=~(1<<31),r=n,h=-1,l=h;for(let _=0;_<this._networkSize;_++){const m=this._network[_],o=this._distance.calculateNormalized(m,{r:e,g:i,b:t,a:s})*a|0;o<n&&(n=o,h=_);const u=o-(this._bias[_]>>w._initialBiasShift-G);u<r&&(r=u,l=_);const d=this._freq[_]>>w._betaShift;this._freq[_]-=d,this._bias[_]+=d<<w._gammaShift}return this._freq[h]+=w._beta,this._bias[h]-=w._betaGamma,l}};let b=w;b._prime1=499,b._prime2=491,b._prime3=487,b._prime4=503,b._minpicturebytes=w._prime4,b._nCycles=100,b._initialBiasShift=16,b._initialBias=1<<w._initialBiasShift,b._gammaShift=10,b._betaShift=10,b._beta=w._initialBias>>w._betaShift,b._betaGamma=w._initialBias<<w._gammaShift-w._betaShift,b._radiusBiasShift=6,b._radiusBias=1<<w._radiusBiasShift,b._radiusDecrease=30,b._alphaBiasShift=10,b._initAlpha=1<<w._alphaBiasShift,b._radBiasShift=8,b._radBias=1<<w._radBiasShift,b._alphaRadBiasShift=w._alphaBiasShift+w._radBiasShift,b._alphaRadBias=1<<w._alphaRadBiasShift;/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */const C=3;class vi{constructor(i){this.r=this.g=this.b=this.a=i}toPoint(){return q.createByRGBA(this.r>>C,this.g>>C,this.b>>C,this.a>>C)}subtract(i,e,s,a){this.r-=i,this.g-=e,this.b-=s,this.a-=a}}const y=class extends lt{constructor(t,i=256){super();this._distance=t,this._pointArray=[],this._sampleFactor=1,this._networkSize=i,this._distance.setWhitePoint(255<<C,255<<C,255<<C,255<<C)}sample(t){this._pointArray=this._pointArray.concat(t.getPointArray())}*quantize(){this._init(),yield*this._learn(),yield{palette:this._buildPalette(),progress:100}}_init(){this._freq=[],this._bias=[],this._radPower=[],this._network=[];for(let t=0;t<this._networkSize;t++)this._network[t]=new vi((t<<C+8)/this._networkSize),this._freq[t]=y._initialBias/this._networkSize,this._bias[t]=0}*_learn(){let t=this._sampleFactor;const i=this._pointArray.length;i<y._minpicturebytes&&(t=1);const e=30+(t-1)/3,s=i/t;let a=s/y._nCycles|0,n=y._initAlpha,r=(this._networkSize>>3)*y._radiusBias,h=r>>y._radiusBiasShift;h<=1&&(h=0);for(let m=0;m<h;m++)this._radPower[m]=n*((h*h-m*m)*y._radBias/(h*h));let l;i<y._minpicturebytes?l=1:i%y._prime1!=0?l=y._prime1:i%y._prime2!=0?l=y._prime2:i%y._prime3!=0?l=y._prime3:l=y._prime4;const _=new O(s,99);for(let m=0,o=0;m<s;){_.shouldNotify(m)&&(yield{progress:_.progress});const u=this._pointArray[o],d=u.b<<C,M=u.g<<C,g=u.r<<C,c=u.a<<C,S=this._contest(d,M,g,c);if(this._alterSingle(n,S,d,M,g,c),h!==0&&this._alterNeighbour(h,S,d,M,g,c),o+=l,o>=i&&(o-=i),m++,a===0&&(a=1),m%a==0){n-=n/e,r-=r/y._radiusDecrease,h=r>>y._radiusBiasShift,h<=1&&(h=0);for(let x=0;x<h;x++)this._radPower[x]=n*((h*h-x*x)*y._radBias/(h*h))}}}_buildPalette(){const t=new ot;return this._network.forEach(i=>{t.add(i.toPoint())}),t.sort(),t}_alterNeighbour(t,i,e,s,a,n){let r=i-t;r<-1&&(r=-1);let h=i+t;h>this._networkSize&&(h=this._networkSize);let l=i+1,_=i-1,m=1;for(;l<h||_>r;){const o=this._radPower[m++]/y._alphaRadBias;if(l<h){const u=this._network[l++];u.subtract(o*(u.r-a),o*(u.g-s),o*(u.b-e),o*(u.a-n))}if(_>r){const u=this._network[_--];u.subtract(o*(u.r-a),o*(u.g-s),o*(u.b-e),o*(u.a-n))}}}_alterSingle(t,i,e,s,a,n){t/=y._initAlpha;const r=this._network[i];r.subtract(t*(r.r-a),t*(r.g-s),t*(r.b-e),t*(r.a-n))}_contest(t,i,e,s){const a=255*4<<C;let n=~(1<<31),r=n,h=-1,l=h;for(let _=0;_<this._networkSize;_++){const m=this._network[_],o=this._distance.calculateNormalized(m,{r:e,g:i,b:t,a:s})*a;o<n&&(n=o,h=_);const u=o-(this._bias[_]>>y._initialBiasShift-C);u<r&&(r=u,l=_);const d=this._freq[_]>>y._betaShift;this._freq[_]-=d,this._bias[_]+=d<<y._gammaShift}return this._freq[h]+=y._beta,this._bias[h]-=y._betaGamma,l}};let B=y;B._prime1=499,B._prime2=491,B._prime3=487,B._prime4=503,B._minpicturebytes=y._prime4,B._nCycles=100,B._initialBiasShift=16,B._initialBias=1<<y._initialBiasShift,B._gammaShift=10,B._betaShift=10,B._beta=y._initialBias>>y._betaShift,B._betaGamma=y._initialBias<<y._gammaShift-y._betaShift,B._radiusBiasShift=6,B._radiusBias=1<<y._radiusBiasShift,B._radiusDecrease=30,B._alphaBiasShift=10,B._initAlpha=1<<y._alphaBiasShift,B._radBiasShift=8,B._radBias=1<<y._radBiasShift,B._alphaRadBiasShift=y._alphaBiasShift+y._radBiasShift,B._alphaRadBias=1<<y._alphaRadBiasShift;/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */const mt=class{constructor(t,i){this._method=t,this._minHueCols=i<<2,this._initColors=i<<2,this._hueStats=new ri(mt._hueGroups,this._minHueCols),this._histogram=Object.create(null)}sample(t){switch(this._method){case 1:this._colorStats1D(t);break;case 2:this._colorStats2D(t);break}}getImportanceSortedColorsIDXI32(){const t=qt(Object.keys(this._histogram),(e,s)=>this._histogram[s]-this._histogram[e]);if(t.length===0)return[];let i;switch(this._method){case 1:const e=Math.min(t.length,this._initColors),s=t[e-1],a=this._histogram[s];i=t.slice(0,e);let n=e;const r=t.length;for(;n<r&&this._histogram[t[n]]===a;)i.push(t[n++]);this._hueStats.injectIntoArray(i);break;case 2:i=t;break;default:throw new Error("Incorrect method")}return i.map(e=>+e)}_colorStats1D(t){const i=this._histogram,e=t.getPointArray(),s=e.length;for(let a=0;a<s;a++){const n=e[a].uint32;this._hueStats.check(n),n in i?i[n]++:i[n]=1}}_colorStats2D(t){const i=t.getWidth(),e=t.getHeight(),s=t.getPointArray(),a=mt._boxSize[0],n=mt._boxSize[1],r=a*n,h=this._makeBoxes(i,e,a,n),l=this._histogram;h.forEach(_=>{let m=Math.round(_.w*_.h/r)*mt._boxPixels;m<2&&(m=2);const o={};this._iterateBox(_,i,u=>{const d=s[u].uint32;this._hueStats.check(d),d in l?l[d]++:d in o?++o[d]>=m&&(l[d]=o[d]):o[d]=1})}),this._hueStats.injectIntoDictionary(l)}_iterateBox(t,i,e){const s=t,a=s.y*i+s.x,n=(s.y+s.h-1)*i+(s.x+s.w-1),r=i-s.w+1;let h=0,l=a;do e.call(this,l),l+=++h%s.w==0?r:1;while(l<=n)}_makeBoxes(t,i,e,s){const a=t%e,n=i%s,r=t-a,h=i-n,l=[];for(let _=0;_<i;_+=s)for(let m=0;m<t;m+=e)l.push({x:m,y:_,w:m===r?a:e,h:_===h?n:s});return l}};let _t=mt;_t._boxSize=[64,64],_t._boxPixels=2,_t._hueGroups=10;/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */class Gi{constructor(i,e,s){this.index=i,this.color=e,this.distance=s}}class li extends lt{constructor(i,e=256,s=2){super();this._distance=i,this._colors=e,this._histogram=new _t(s,e),this._initialDistance=.01,this._distanceIncrement=.005}sample(i){this._histogram.sample(i)}*quantize(){const i=this._histogram.getImportanceSortedColorsIDXI32();if(i.length===0)throw new Error("No colors in image");yield*this._buildPalette(i)}*_buildPalette(i){const e=new ot,s=e.getPointContainer().getPointArray(),a=new Array(i.length);for(let o=0;o<i.length;o++)s.push(q.createByUint32(i[o])),a[o]=1;const n=s.length,r=[];let h=n,l=this._initialDistance;const _=new O(h-this._colors,99);for(;h>this._colors;){r.length=0;for(let o=0;o<n;o++){if(_.shouldNotify(n-h)&&(yield{progress:_.progress}),a[o]===0)continue;const u=s[o];for(let d=o+1;d<n;d++){if(a[d]===0)continue;const M=s[d],g=this._distance.calculateNormalized(u,M);g<l&&(r.push(new Gi(d,M,g)),a[d]=0,h--)}}l+=h>this._colors*3?this._initialDistance:this._distanceIncrement}if(h<this._colors){qt(r,(u,d)=>d.distance-u.distance);let o=0;for(;h<this._colors&&o<r.length;){const u=r[o];a[u.index]=1,h++,o++}}let m=s.length;for(let o=m-1;o>=0;o--)a[o]===0&&(o!==m-1&&(s[o]=s[m-1]),--m);s.length=m,e.sort(),yield{palette:e,progress:100}}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */function K(t){const i=[];for(let e=0;e<t;e++)i[e]=0;return i}function tt(t,i,e,s){const a=new Array(t);for(let n=0;n<t;n++){a[n]=new Array(i);for(let r=0;r<i;r++){a[n][r]=new Array(e);for(let h=0;h<e;h++){a[n][r][h]=new Array(s);for(let l=0;l<s;l++)a[n][r][h][l]=0}}}return a}function it(t,i,e){const s=new Array(t);for(let a=0;a<t;a++){s[a]=new Array(i);for(let n=0;n<i;n++){s[a][n]=new Array(e);for(let r=0;r<e;r++)s[a][n][r]=0}}return s}function et(t,i,e,s,a){for(let n=0;n<i;n++){t[n]=[];for(let r=0;r<e;r++){t[n][r]=[];for(let h=0;h<s;h++)t[n][r][h]=a}}}function st(t,i,e){for(let s=0;s<i;s++)t[s]=e}class oi{}const f=class extends lt{constructor(t,i=256,e=5){super();this._distance=t,this._setQuality(e),this._initialize(i)}sample(t){const i=t.getPointArray();for(let e=0,s=i.length;e<s;e++)this._addColor(i[e]);this._pixels=this._pixels.concat(i)}*quantize(){yield*this._preparePalette();const t=new ot;for(let i=0;i<this._colors;i++)if(this._sums[i]>0){const e=this._sums[i],s=this._reds[i]/e,a=this._greens[i]/e,n=this._blues[i]/e,r=this._alphas[i]/e,h=q.createByRGBA(s|0,a|0,n|0,r|0);t.add(h)}t.sort(),yield{palette:t,progress:100}}*_preparePalette(){yield*this._calculateMoments();let t=0;const i=K(this._colors);for(let r=1;r<this._colors;++r){this._cut(this._cubes[t],this._cubes[r])?(i[t]=this._cubes[t].volume>1?this._calculateVariance(this._cubes[t]):0,i[r]=this._cubes[r].volume>1?this._calculateVariance(this._cubes[r]):0):(i[t]=0,r--),t=0;let h=i[0];for(let l=1;l<=r;++l)i[l]>h&&(h=i[l],t=l);if(h<=0){this._colors=r+1;break}}const e=[],s=[],a=[],n=[];for(let r=0;r<this._colors;++r){const h=f._volume(this._cubes[r],this._weights);h>0?(e[r]=f._volume(this._cubes[r],this._momentsRed)/h|0,s[r]=f._volume(this._cubes[r],this._momentsGreen)/h|0,a[r]=f._volume(this._cubes[r],this._momentsBlue)/h|0,n[r]=f._volume(this._cubes[r],this._momentsAlpha)/h|0):(e[r]=0,s[r]=0,a[r]=0,n[r]=0)}this._reds=K(this._colors+1),this._greens=K(this._colors+1),this._blues=K(this._colors+1),this._alphas=K(this._colors+1),this._sums=K(this._colors+1);for(let r=0,h=this._pixels.length;r<h;r++){const l=this._pixels[r];let m=-1,o=Number.MAX_VALUE;for(let u=0;u<this._colors;u++){const d=e[u],M=s[u],g=a[u],c=n[u],S=this._distance.calculateRaw(d,M,g,c,l.r,l.g,l.b,l.a);S<o&&(o=S,m=u)}this._reds[m]+=l.r,this._greens[m]+=l.g,this._blues[m]+=l.b,this._alphas[m]+=l.a,this._sums[m]++}}_addColor(t){const i=8-this._significantBitsPerChannel,e=(t.r>>i)+1,s=(t.g>>i)+1,a=(t.b>>i)+1,n=(t.a>>i)+1;this._weights[n][e][s][a]++,this._momentsRed[n][e][s][a]+=t.r,this._momentsGreen[n][e][s][a]+=t.g,this._momentsBlue[n][e][s][a]+=t.b,this._momentsAlpha[n][e][s][a]+=t.a,this._moments[n][e][s][a]+=this._table[t.r]+this._table[t.g]+this._table[t.b]+this._table[t.a]}*_calculateMoments(){const t=[],i=[],e=[],s=[],a=[],n=[],r=it(this._sideSize,this._sideSize,this._sideSize),h=it(this._sideSize,this._sideSize,this._sideSize),l=it(this._sideSize,this._sideSize,this._sideSize),_=it(this._sideSize,this._sideSize,this._sideSize),m=it(this._sideSize,this._sideSize,this._sideSize),o=it(this._sideSize,this._sideSize,this._sideSize);let u=0;const d=new O(this._alphaMaxSideIndex*this._maxSideIndex,99);for(let M=1;M<=this._alphaMaxSideIndex;++M){et(r,this._sideSize,this._sideSize,this._sideSize,0),et(h,this._sideSize,this._sideSize,this._sideSize,0),et(l,this._sideSize,this._sideSize,this._sideSize,0),et(_,this._sideSize,this._sideSize,this._sideSize,0),et(m,this._sideSize,this._sideSize,this._sideSize,0),et(o,this._sideSize,this._sideSize,this._sideSize,0);for(let g=1;g<=this._maxSideIndex;++g,++u){d.shouldNotify(u)&&(yield{progress:d.progress}),st(t,this._sideSize,0),st(i,this._sideSize,0),st(e,this._sideSize,0),st(s,this._sideSize,0),st(a,this._sideSize,0),st(n,this._sideSize,0);for(let c=1;c<=this._maxSideIndex;++c){let S=0,x=0,z=0,R=0,P=0,U=0;for(let p=1;p<=this._maxSideIndex;++p)S+=this._weights[M][g][c][p],x+=this._momentsRed[M][g][c][p],z+=this._momentsGreen[M][g][c][p],R+=this._momentsBlue[M][g][c][p],P+=this._momentsAlpha[M][g][c][p],U+=this._moments[M][g][c][p],t[p]+=S,i[p]+=x,e[p]+=z,s[p]+=R,a[p]+=P,n[p]+=U,r[g][c][p]=r[g-1][c][p]+t[p],h[g][c][p]=h[g-1][c][p]+i[p],l[g][c][p]=l[g-1][c][p]+e[p],_[g][c][p]=_[g-1][c][p]+s[p],m[g][c][p]=m[g-1][c][p]+a[p],o[g][c][p]=o[g-1][c][p]+n[p],this._weights[M][g][c][p]=this._weights[M-1][g][c][p]+r[g][c][p],this._momentsRed[M][g][c][p]=this._momentsRed[M-1][g][c][p]+h[g][c][p],this._momentsGreen[M][g][c][p]=this._momentsGreen[M-1][g][c][p]+l[g][c][p],this._momentsBlue[M][g][c][p]=this._momentsBlue[M-1][g][c][p]+_[g][c][p],this._momentsAlpha[M][g][c][p]=this._momentsAlpha[M-1][g][c][p]+m[g][c][p],this._moments[M][g][c][p]=this._moments[M-1][g][c][p]+o[g][c][p]}}}}static _volumeFloat(t,i){return i[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMaximum]-i[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMaximum]-i[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMaximum]+i[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]-i[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMaximum]+i[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]+i[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-i[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(i[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMinimum]-i[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]-i[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+i[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]-i[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]+i[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]+i[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]-i[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum])}static _volume(t,i){return f._volumeFloat(t,i)|0}static _top(t,i,e,s){let a;switch(i){case f._alpha:a=s[e][t.redMaximum][t.greenMaximum][t.blueMaximum]-s[e][t.redMaximum][t.greenMinimum][t.blueMaximum]-s[e][t.redMinimum][t.greenMaximum][t.blueMaximum]+s[e][t.redMinimum][t.greenMinimum][t.blueMaximum]-(s[e][t.redMaximum][t.greenMaximum][t.blueMinimum]-s[e][t.redMaximum][t.greenMinimum][t.blueMinimum]-s[e][t.redMinimum][t.greenMaximum][t.blueMinimum]+s[e][t.redMinimum][t.greenMinimum][t.blueMinimum]);break;case f._red:a=s[t.alphaMaximum][e][t.greenMaximum][t.blueMaximum]-s[t.alphaMaximum][e][t.greenMinimum][t.blueMaximum]-s[t.alphaMinimum][e][t.greenMaximum][t.blueMaximum]+s[t.alphaMinimum][e][t.greenMinimum][t.blueMaximum]-(s[t.alphaMaximum][e][t.greenMaximum][t.blueMinimum]-s[t.alphaMaximum][e][t.greenMinimum][t.blueMinimum]-s[t.alphaMinimum][e][t.greenMaximum][t.blueMinimum]+s[t.alphaMinimum][e][t.greenMinimum][t.blueMinimum]);break;case f._green:a=s[t.alphaMaximum][t.redMaximum][e][t.blueMaximum]-s[t.alphaMaximum][t.redMinimum][e][t.blueMaximum]-s[t.alphaMinimum][t.redMaximum][e][t.blueMaximum]+s[t.alphaMinimum][t.redMinimum][e][t.blueMaximum]-(s[t.alphaMaximum][t.redMaximum][e][t.blueMinimum]-s[t.alphaMaximum][t.redMinimum][e][t.blueMinimum]-s[t.alphaMinimum][t.redMaximum][e][t.blueMinimum]+s[t.alphaMinimum][t.redMinimum][e][t.blueMinimum]);break;case f._blue:a=s[t.alphaMaximum][t.redMaximum][t.greenMaximum][e]-s[t.alphaMaximum][t.redMaximum][t.greenMinimum][e]-s[t.alphaMaximum][t.redMinimum][t.greenMaximum][e]+s[t.alphaMaximum][t.redMinimum][t.greenMinimum][e]-(s[t.alphaMinimum][t.redMaximum][t.greenMaximum][e]-s[t.alphaMinimum][t.redMaximum][t.greenMinimum][e]-s[t.alphaMinimum][t.redMinimum][t.greenMaximum][e]+s[t.alphaMinimum][t.redMinimum][t.greenMinimum][e]);break;default:throw new Error("impossible")}return a|0}static _bottom(t,i,e){switch(i){case f._alpha:return-e[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMaximum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-e[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case f._red:return-e[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMaximum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMaximum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-e[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case f._green:return-e[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMaximum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMaximum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMaximum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMaximum]-(-e[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);case f._blue:return-e[t.alphaMaximum][t.redMaximum][t.greenMaximum][t.blueMinimum]+e[t.alphaMaximum][t.redMaximum][t.greenMinimum][t.blueMinimum]+e[t.alphaMaximum][t.redMinimum][t.greenMaximum][t.blueMinimum]-e[t.alphaMaximum][t.redMinimum][t.greenMinimum][t.blueMinimum]-(-e[t.alphaMinimum][t.redMaximum][t.greenMaximum][t.blueMinimum]+e[t.alphaMinimum][t.redMaximum][t.greenMinimum][t.blueMinimum]+e[t.alphaMinimum][t.redMinimum][t.greenMaximum][t.blueMinimum]-e[t.alphaMinimum][t.redMinimum][t.greenMinimum][t.blueMinimum]);default:return 0}}_calculateVariance(t){const i=f._volume(t,this._momentsRed),e=f._volume(t,this._momentsGreen),s=f._volume(t,this._momentsBlue),a=f._volume(t,this._momentsAlpha),n=f._volumeFloat(t,this._moments),r=f._volume(t,this._weights),h=i*i+e*e+s*s+a*a;return n-h/r}_maximize(t,i,e,s,a,n,r,h,l){const _=f._bottom(t,i,this._momentsRed)|0,m=f._bottom(t,i,this._momentsGreen)|0,o=f._bottom(t,i,this._momentsBlue)|0,u=f._bottom(t,i,this._momentsAlpha)|0,d=f._bottom(t,i,this._weights)|0;let M=0,g=-1;for(let c=e;c<s;++c){let S=_+f._top(t,i,c,this._momentsRed),x=m+f._top(t,i,c,this._momentsGreen),z=o+f._top(t,i,c,this._momentsBlue),R=u+f._top(t,i,c,this._momentsAlpha),P=d+f._top(t,i,c,this._weights);if(P!==0){let U=S*S+x*x+z*z+R*R,p=U/P;S=a-S,x=n-x,z=r-z,R=h-R,P=l-P,P!==0&&(U=S*S+x*x+z*z+R*R,p+=U/P,p>M&&(M=p,g=c))}}return{max:M,position:g}}_cut(t,i){let e;const s=f._volume(t,this._momentsRed),a=f._volume(t,this._momentsGreen),n=f._volume(t,this._momentsBlue),r=f._volume(t,this._momentsAlpha),h=f._volume(t,this._weights),l=this._maximize(t,f._red,t.redMinimum+1,t.redMaximum,s,a,n,r,h),_=this._maximize(t,f._green,t.greenMinimum+1,t.greenMaximum,s,a,n,r,h),m=this._maximize(t,f._blue,t.blueMinimum+1,t.blueMaximum,s,a,n,r,h),o=this._maximize(t,f._alpha,t.alphaMinimum+1,t.alphaMaximum,s,a,n,r,h);if(o.max>=l.max&&o.max>=_.max&&o.max>=m.max){if(e=f._alpha,o.position<0)return!1}else l.max>=o.max&&l.max>=_.max&&l.max>=m.max?e=f._red:_.max>=o.max&&_.max>=l.max&&_.max>=m.max?e=f._green:e=f._blue;switch(i.redMaximum=t.redMaximum,i.greenMaximum=t.greenMaximum,i.blueMaximum=t.blueMaximum,i.alphaMaximum=t.alphaMaximum,e){case f._red:i.redMinimum=t.redMaximum=l.position,i.greenMinimum=t.greenMinimum,i.blueMinimum=t.blueMinimum,i.alphaMinimum=t.alphaMinimum;break;case f._green:i.greenMinimum=t.greenMaximum=_.position,i.redMinimum=t.redMinimum,i.blueMinimum=t.blueMinimum,i.alphaMinimum=t.alphaMinimum;break;case f._blue:i.blueMinimum=t.blueMaximum=m.position,i.redMinimum=t.redMinimum,i.greenMinimum=t.greenMinimum,i.alphaMinimum=t.alphaMinimum;break;case f._alpha:i.alphaMinimum=t.alphaMaximum=o.position,i.blueMinimum=t.blueMinimum,i.redMinimum=t.redMinimum,i.greenMinimum=t.greenMinimum;break}return t.volume=(t.redMaximum-t.redMinimum)*(t.greenMaximum-t.greenMinimum)*(t.blueMaximum-t.blueMinimum)*(t.alphaMaximum-t.alphaMinimum),i.volume=(i.redMaximum-i.redMinimum)*(i.greenMaximum-i.greenMinimum)*(i.blueMaximum-i.blueMinimum)*(i.alphaMaximum-i.alphaMinimum),!0}_initialize(t){this._colors=t,this._cubes=[];for(let i=0;i<t;i++)this._cubes[i]=new oi;this._cubes[0].redMinimum=0,this._cubes[0].greenMinimum=0,this._cubes[0].blueMinimum=0,this._cubes[0].alphaMinimum=0,this._cubes[0].redMaximum=this._maxSideIndex,this._cubes[0].greenMaximum=this._maxSideIndex,this._cubes[0].blueMaximum=this._maxSideIndex,this._cubes[0].alphaMaximum=this._alphaMaxSideIndex,this._weights=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsRed=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsGreen=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsBlue=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._momentsAlpha=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._moments=tt(this._alphaSideSize,this._sideSize,this._sideSize,this._sideSize),this._table=[];for(let i=0;i<256;++i)this._table[i]=i*i;this._pixels=[]}_setQuality(t=5){this._significantBitsPerChannel=t,this._maxSideIndex=1<<this._significantBitsPerChannel,this._alphaMaxSideIndex=this._maxSideIndex,this._sideSize=this._maxSideIndex+1,this._alphaSideSize=this._alphaMaxSideIndex+1}};let at=f;at._alpha=3,at._red=2,at._green=1,at._blue=0;var Ci=k(563);/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 *//**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */class wt{quantizeSync(i,e){for(const s of this.quantize(i,e))if(s.pointContainer)return s.pointContainer;throw new Error("unreachable")}}var qi=k(516);/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */class mi extends wt{constructor(i){super();this._distance=i}*quantize(i,e){const s=i.getPointArray(),a=i.getWidth(),n=i.getHeight(),r=new O(n,99);for(let h=0;h<n;h++){r.shouldNotify(h)&&(yield{progress:r.progress});for(let l=0,_=h*a;l<a;l++,_++){const m=s[_];m.from(e.getNearestColor(this._distance,m))}}yield{pointContainer:i,progress:100}}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */var H;(function(t){t[t.FloydSteinberg=0]="FloydSteinberg",t[t.FalseFloydSteinberg=1]="FalseFloydSteinberg",t[t.Stucki=2]="Stucki",t[t.Atkinson=3]="Atkinson",t[t.Jarvis=4]="Jarvis",t[t.Burkes=5]="Burkes",t[t.Sierra=6]="Sierra",t[t.TwoSierra=7]="TwoSierra",t[t.SierraLite=8]="SierraLite"})(H||(H={}));class F extends wt{constructor(i,e,s=!0,a=0,n=!1){super();this._setKernel(e),this._distance=i,this._minColorDistance=a,this._serpentine=s,this._calculateErrorLikeGIMP=n}*quantize(i,e){const s=i.getPointArray(),a=new q,n=i.getWidth(),r=i.getHeight(),h=[];let l=1,_=1;for(const o of this._kernel){const u=o[2]+1;_<u&&(_=u)}for(let o=0;o<_;o++)this._fillErrorLine(h[o]=[],n);const m=new O(r,99);for(let o=0;o<r;o++){m.shouldNotify(o)&&(yield{progress:m.progress}),this._serpentine&&(l*=-1);const u=o*n,d=l===1?0:n-1,M=l===1?n:-1;this._fillErrorLine(h[0],n),h.push(h.shift());const g=h[0];for(let c=d,S=u+d;c!==M;c+=l,S+=l){const x=s[S],z=g[c];a.from(x);const R=q.createByRGBA(Q(x.r+z[0]),Q(x.g+z[1]),Q(x.b+z[2]),Q(x.a+z[3])),P=e.getNearestColor(this._distance,R);if(x.from(P),this._minColorDistance&&this._distance.calculateNormalized(x,P)<this._minColorDistance)continue;let U,p,ut,Y;this._calculateErrorLikeGIMP?(U=R.r-P.r,p=R.g-P.g,ut=R.b-P.b,Y=R.a-P.a):(U=a.r-P.r,p=a.g-P.g,ut=a.b-P.b,Y=a.a-P.a);const zt=l===1?0:this._kernel.length-1,Qt=l===1?this._kernel.length:-1;for(let $=zt;$!==Qt;$+=l){const ct=this._kernel[$][1]*l,dt=this._kernel[$][2];if(ct+c>=0&&ct+c<n&&dt+o>=0&&dt+o<r){const rt=this._kernel[$][0],Z=h[dt][ct+c];Z[0]+=U*rt,Z[1]+=p*rt,Z[2]+=ut*rt,Z[3]+=Y*rt}}}}yield{pointContainer:i,progress:100}}_fillErrorLine(i,e){i.length>e&&(i.length=e);const s=i.length;for(let a=0;a<s;a++){const n=i[a];n[0]=n[1]=n[2]=n[3]=0}for(let a=s;a<e;a++)i[a]=[0,0,0,0]}_setKernel(i){switch(i){case 0:this._kernel=[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]];break;case 1:this._kernel=[[3/8,1,0],[3/8,0,1],[2/8,1,1]];break;case 2:this._kernel=[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]];break;case 3:this._kernel=[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]];break;case 4:this._kernel=[[7/48,1,0],[5/48,2,0],[3/48,-2,1],[5/48,-1,1],[7/48,0,1],[5/48,1,1],[3/48,2,1],[1/48,-2,2],[3/48,-1,2],[5/48,0,2],[3/48,1,2],[1/48,2,2]];break;case 5:this._kernel=[[8/32,1,0],[4/32,2,0],[2/32,-2,1],[4/32,-1,1],[8/32,0,1],[4/32,1,1],[2/32,2,1]];break;case 6:this._kernel=[[5/32,1,0],[3/32,2,0],[2/32,-2,1],[4/32,-1,1],[5/32,0,1],[4/32,1,1],[2/32,2,1],[2/32,-1,2],[3/32,0,2],[2/32,1,2]];break;case 7:this._kernel=[[4/16,1,0],[3/16,2,0],[1/16,-2,1],[2/16,-1,1],[3/16,0,1],[2/16,1,1],[1/16,2,1]];break;case 8:this._kernel=[[2/4,1,0],[1/4,-1,1],[1/4,0,1]];break;default:throw new Error(`ErrorDiffusionArray: unknown kernel = ${i}`)}}}var _i;(function(t){t[t.NONE=0]="NONE",t[t.UP=1]="UP",t[t.LEFT=2]="LEFT",t[t.RIGHT=3]="RIGHT",t[t.DOWN=4]="DOWN"})(_i||(_i={}));function*Ni(t,i,e){const s=Math.max(t,i),a=Math.floor(Math.log(s)/Math.log(2)+1),n=new O(t*i,99),r={width:t,height:i,level:a,callback:e,tracker:n,index:0,x:0,y:0};yield*E(r,1),D(r,0)}function*E(t,i){if(!(t.level<1)){switch(t.tracker.shouldNotify(t.index)&&(yield{progress:t.tracker.progress}),t.level--,i){case 2:yield*E(t,1),D(t,3),yield*E(t,2),D(t,4),yield*E(t,2),D(t,2),yield*E(t,4);break;case 3:yield*E(t,4),D(t,2),yield*E(t,3),D(t,1),yield*E(t,3),D(t,3),yield*E(t,1);break;case 1:yield*E(t,2),D(t,4),yield*E(t,1),D(t,3),yield*E(t,1),D(t,1),yield*E(t,3);break;case 4:yield*E(t,3),D(t,1),yield*E(t,4),D(t,2),yield*E(t,4),D(t,4),yield*E(t,2);break;default:break}t.level++}}function D(t,i){switch(t.x>=0&&t.x<t.width&&t.y>=0&&t.y<t.height&&(t.callback(t.x,t.y),t.index++),i){case 2:t.x--;break;case 3:t.x++;break;case 1:t.y--;break;case 4:t.y++;break}}/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */class yt extends wt{constructor(i,e=16,s=1){super();this._distance=i,this._errorQueueSize=e,this._weights=yt._createWeights(s,e)}*quantize(i,e){const s=i.getPointArray(),a=i.getWidth(),n=i.getHeight(),r=[];let h=0;for(let l=0;l<this._errorQueueSize;l++)r[l]={r:0,g:0,b:0,a:0};yield*Ni(a,n,(l,_)=>{const m=s[l+_*a];let{r:o,g:u,b:d,a:M}=m;for(let x=0;x<this._errorQueueSize;x++){const z=this._weights[x],R=r[(x+h)%this._errorQueueSize];o+=R.r*z,u+=R.g*z,d+=R.b*z,M+=R.a*z}const g=q.createByRGBA(Q(o),Q(u),Q(d),Q(M)),c=e.getNearestColor(this._distance,g);h=(h+1)%this._errorQueueSize;const S=(h+this._errorQueueSize-1)%this._errorQueueSize;r[S].r=m.r-c.r,r[S].g=m.g-c.g,r[S].b=m.b-c.b,r[S].a=m.a-c.a,m.from(c)}),yield{pointContainer:i,progress:100}}static _createWeights(i,e){const s=[],a=Math.exp(Math.log(e)/(e-1));for(let n=0,r=1;n<e;n++)s[n]=(r+.5|0)/e*i,r*=a;return s}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */var nt=Math.pow,Yi=void 0;/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */const Di=.01,Ti=.03;function Li(t,i){if(t.getHeight()!==i.getHeight()||t.getWidth()!==i.getWidth())throw new Error("Images have different sizes!");const s=(1<<8)-1,a=nt(Di*s,2),n=nt(Ti*s,2);let r=0,h=0;return Qi(t,i,(l,_,m,o)=>{let u=0,d=0,M=0;for(let z=0;z<l.length;z++)d+=nt(l[z]-m,2),M+=nt(_[z]-o,2),u+=(l[z]-m)*(_[z]-o);const g=l.length-1;d/=g,M/=g,u/=g;const c=(2*m*o+a)*(2*u+n),S=(nt(m,2)+nt(o,2)+a)*(d+M+n);h+=c/S,r++}),h/r}function Qi(t,i,e){const s=8,a=t.getWidth(),n=t.getHeight();for(let r=0;r<n;r+=s)for(let h=0;h<a;h+=s){const l=Math.min(s,a-h),_=Math.min(s,n-r),m=ui(t,h,r,l,_),o=ui(i,h,r,l,_),u=ci(m),d=ci(o);e(m,o,u,d)}}function ui(t,i,e,s,a){const n=t.getPointArray(),r=[];let h=0;for(let l=e;l<e+a;l++){const _=l*t.getWidth();for(let m=i;m<i+s;m++){const o=n[_+m];r[h]=o.r*I.RED+o.g*I.GREEN+o.b*I.BLUE,h++}}return r}function ci(t){let i=0;for(const e of t)i+=e;return i/t.length}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */var Zi=void 0,di=(t,i,e)=>new Promise((s,a)=>{var n=l=>{try{h(e.next(l))}catch(_){a(_)}},r=l=>{try{h(e.throw(l))}catch(_){a(_)}},h=l=>l.done?s(l.value):Promise.resolve(l.value).then(n,r);h((e=e.apply(t,i)).next())});/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */const St=typeof setImmediate=="function"?setImmediate:typeof process!="undefined"&&typeof(process==null?void 0:process.nextTick)=="function"?t=>process.nextTick(t):t=>setTimeout(t,0);function Hi(t,{colorDistanceFormula:i,paletteQuantization:e,colors:s}={}){const a=kt(i),n=Mi(a,e,s);return t.forEach(r=>n.sample(r)),n.quantizeSync()}function Ui(t){return di(this,arguments,function*(i,{colorDistanceFormula:e,paletteQuantization:s,colors:a,onProgress:n}={}){return new Promise((r,h)=>{const l=kt(e),_=Mi(l,s,a);i.forEach(d=>_.sample(d));let m;const o=_.quantize(),u=()=>{try{const d=o.next();d.done?r(m):(d.value.palette&&(m=d.value.palette),n&&n(d.value.progress),St(u))}catch(d){h(d)}};St(u)})})}function Wi(t,i,{colorDistanceFormula:e,imageQuantization:s}={}){const a=kt(e);return gi(a,s).quantizeSync(t,i)}function ji(t,i){return di(this,arguments,function*(e,s,{colorDistanceFormula:a,imageQuantization:n,onProgress:r}={}){return new Promise((h,l)=>{const _=kt(a),m=gi(_,n);let o;const u=m.quantize(e,s),d=()=>{try{const M=u.next();M.done?h(o):(M.value.pointContainer&&(o=M.value.pointContainer),r&&r(M.value.progress),St(d))}catch(M){l(M)}};St(d)})})}function kt(t="euclidean-bt709"){switch(t){case"cie94-graphic-arts":return new Jt;case"cie94-textiles":return new $t;case"ciede2000":return new W;case"color-metric":return new Yt;case"euclidean":return new Zt;case"euclidean-bt709":return new Kt;case"euclidean-bt709-noalpha":return new ti;case"manhattan":return new ii;case"manhattan-bt709":return new si;case"manhattan-nommyde":return new ei;case"pngquant":return new ai;default:throw new Error(`Unknown colorDistanceFormula ${t}`)}}function gi(t,i="floyd-steinberg"){switch(i){case"nearest":return new mi(t);case"riemersma":return new yt(t);case"floyd-steinberg":return new F(t,H.FloydSteinberg);case"false-floyd-steinberg":return new F(t,H.FalseFloydSteinberg);case"stucki":return new F(t,H.Stucki);case"atkinson":return new F(t,H.Atkinson);case"jarvis":return new F(t,H.Jarvis);case"burkes":return new F(t,H.Burkes);case"sierra":return new F(t,H.Sierra);case"two-sierra":return new F(t,H.TwoSierra);case"sierra-lite":return new F(t,H.SierraLite);default:throw new Error(`Unknown imageQuantization ${i}`)}}function Mi(t,i="wuquant",e=256){switch(i){case"neuquant":return new b(t,e);case"rgbquant":return new li(t,e);case"wuquant":return new at(t,e);case"neuquant-float":return new B(t,e);default:throw new Error(`Unknown paletteQuantization ${i}`)}}/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */})(),At})()});
