{"version":3,"file":"neuquantFloat.js","sourceRoot":"","sources":["../../../../../src/palette/neuquant/neuquantFloat.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;GAmBG;AACH;;;;;;GAMG;AACH,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAC;AAC9C,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAG1C,OAAO,EAAE,wBAAwB,EAAE,MAAM,qBAAqB,CAAC;AAE/D,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAE9C,yBAAyB;AACzB,MAAM,gBAAgB,GAAG,CAAC,CAAC;AAE3B,MAAM,WAAW;IACf,CAAC,CAAS;IACV,CAAC,CAAS;IACV,CAAC,CAAS;IACV,CAAC,CAAS;IAEV,YAAY,YAAoB;QAC9B,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,YAAY,CAAC;IACnD,CAAC;IAED;;;;OAIG;IACH,OAAO;QACL,OAAO,KAAK,CAAC,YAAY,CACvB,IAAI,CAAC,CAAC,IAAI,gBAAgB,EAC1B,IAAI,CAAC,CAAC,IAAI,gBAAgB,EAC1B,IAAI,CAAC,CAAC,IAAI,gBAAgB,EAC1B,IAAI,CAAC,CAAC,IAAI,gBAAgB,CAC3B,CAAC;IACJ,CAAC;IAED,QAAQ,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,CAAS;QACjD,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;CACF;AAED,MAAM,OAAO,aAAc,SAAQ,wBAAwB;IACzD;;;OAGG;IACK,MAAM,CAAU,OAAO,GAAG,GAAG,CAAC;IAC9B,MAAM,CAAU,OAAO,GAAG,GAAG,CAAC;IAC9B,MAAM,CAAU,OAAO,GAAG,GAAG,CAAC;IAC9B,MAAM,CAAU,OAAO,GAAG,GAAG,CAAC;IAC9B,MAAM,CAAU,gBAAgB,GAAG,aAAa,CAAC,OAAO,CAAC;IAEjE,yBAAyB;IACjB,MAAM,CAAU,QAAQ,GAAG,GAAG,CAAC;IAEvC,yBAAyB;IACjB,MAAM,CAAU,iBAAiB,GAAG,EAAE,CAAC;IAE/C,qBAAqB;IACb,MAAM,CAAU,YAAY,GAAG,CAAC,IAAI,aAAa,CAAC,iBAAiB,CAAC;IACpE,MAAM,CAAU,WAAW,GAAG,EAAE,CAAC;IAEzC,eAAe;IACf,iCAAiC;IACjC,yEAAyE;IACjE,MAAM,CAAU,UAAU,GAAG,EAAE,CAAC;IAChC,MAAM,CAAU,KAAK,GAC3B,aAAa,CAAC,YAAY,IAAI,aAAa,CAAC,UAAU,CAAC;IAEzD,gBAAgB;IACR,MAAM,CAAU,UAAU,GAChC,aAAa,CAAC,YAAY;QAC1B,CAAC,aAAa,CAAC,WAAW,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC;IAEzD;;OAEG;IACK,MAAM,CAAU,gBAAgB,GAAG,CAAC,CAAC;IAE7C,2BAA2B;IACnB,MAAM,CAAU,WAAW,GAAG,CAAC,IAAI,aAAa,CAAC,gBAAgB,CAAC;IAE1E,+CAA+C;IACvC,MAAM,CAAU,eAAe,GAAG,EAAE,CAAC;IAE7C,sCAAsC;IAEtC,sBAAsB;IACd,MAAM,CAAU,eAAe,GAAG,EAAE,CAAC;IAE7C,oBAAoB;IACZ,MAAM,CAAU,UAAU,GAAG,CAAC,IAAI,aAAa,CAAC,eAAe,CAAC;IAExE,4DAA4D;IACpD,MAAM,CAAU,aAAa,GAAG,CAAC,CAAC;IAClC,MAAM,CAAU,QAAQ,GAAG,CAAC,IAAI,aAAa,CAAC,aAAa,CAAC;IAC5D,MAAM,CAAU,kBAAkB,GACxC,aAAa,CAAC,eAAe,GAAG,aAAa,CAAC,aAAa,CAAC;IACtD,MAAM,CAAU,aAAa,GAAG,CAAC,IAAI,aAAa,CAAC,kBAAkB,CAAC;IAEtE,WAAW,CAAW;IACb,YAAY,CAAU;IAC/B,QAAQ,CAAiB;IAEjC,4BAA4B;IACX,aAAa,CAAU;IAChC,SAAS,CAAY;IAE7B,oCAAoC;IAC5B,KAAK,CAAY;IAEzB,qCAAqC;IAC7B,KAAK,CAAY;IACR,SAAS,CAA6B;IAEvD,YACE,uBAAmD,EACnD,MAAM,GAAG,GAAG;QAEZ,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,uBAAuB,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;QAE3B,IAAI,CAAC,SAAS,CAAC,aAAa,CAC1B,GAAG,IAAI,gBAAgB,EACvB,GAAG,IAAI,gBAAgB,EACvB,GAAG,IAAI,gBAAgB,EACvB,GAAG,IAAI,gBAAgB,CACxB,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,cAA8B;QACnC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,CAAC,CAAC;IAC7E,CAAC;IAED,CAAC,QAAQ;QACP,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QAErB,MAAM;YACJ,OAAO,EAAE,IAAI,CAAC,aAAa,EAAE;YAC7B,QAAQ,EAAE,GAAG;SACd,CAAC;IACJ,CAAC;IAEO,KAAK;QACX,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,WAAW,CAChC,CAAC,CAAC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,CAClD,CAAC;YAEF,sBAAsB;YACtB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;YAC/D,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SACnB;IACH,CAAC;IAED;;OAEG;IACK,CAAC,MAAM;QACb,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;QAEtC,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QAC7C,IAAI,YAAY,GAAG,aAAa,CAAC,gBAAgB;YAAE,YAAY,GAAG,CAAC,CAAC;QAEpE,MAAM,QAAQ,GAAG,EAAE,GAAG,CAAC,YAAY,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAC7C,MAAM,cAAc,GAAG,YAAY,GAAG,YAAY,CAAC;QAEnD,IAAI,KAAK,GAAG,CAAC,cAAc,GAAG,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,aAAa,CAAC,UAAU,CAAC;QACrC,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,CAAC,GAAG,aAAa,CAAC,WAAW,CAAC;QAElE,IAAI,GAAG,GAAG,MAAM,IAAI,aAAa,CAAC,gBAAgB,CAAC;QACnD,IAAI,GAAG,IAAI,CAAC;YAAE,GAAG,GAAG,CAAC,CAAC;QAEtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC5B,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBACf,KAAK,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;SAC1E;QAED,IAAI,IAAI,CAAC;QACT,IAAI,YAAY,GAAG,aAAa,CAAC,gBAAgB,EAAE;YACjD,IAAI,GAAG,CAAC,CAAC;SACV;aAAM,IAAI,YAAY,GAAG,aAAa,CAAC,OAAO,KAAK,CAAC,EAAE;YACrD,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC;SAC9B;aAAM,IAAI,YAAY,GAAG,aAAa,CAAC,OAAO,KAAK,CAAC,EAAE;YACrD,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC;SAC9B;aAAM,IAAI,YAAY,GAAG,aAAa,CAAC,OAAO,KAAK,CAAC,EAAE;YACrD,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC;SAC9B;aAAM;YACL,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC;SAC9B;QAED,MAAM,OAAO,GAAG,IAAI,eAAe,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QACxD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,GAAI;YACpD,IAAI,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;gBAC3B,MAAM;oBACJ,QAAQ,EAAE,OAAO,CAAC,QAAQ;iBAC3B,CAAC;aACH;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;YAC3C,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,gBAAgB,CAAC;YACtC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,gBAAgB,CAAC;YACtC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,gBAAgB,CAAC;YACtC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI,gBAAgB,CAAC;YACtC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAE9C,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAClD,IAAI,GAAG,KAAK,CAAC;gBAAE,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,WAAW,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAElE,sBAAsB;YACtB,UAAU,IAAI,IAAI,CAAC;YACnB,IAAI,UAAU,IAAI,YAAY;gBAAE,UAAU,IAAI,YAAY,CAAC;YAC3D,CAAC,EAAE,CAAC;YAEJ,IAAI,KAAK,KAAK,CAAC;gBAAE,KAAK,GAAG,CAAC,CAAC;YAE3B,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE;gBACnB,KAAK,IAAI,KAAK,GAAG,QAAQ,CAAC;gBAC1B,MAAM,IAAI,MAAM,GAAG,aAAa,CAAC,eAAe,CAAC;gBACjD,GAAG,GAAG,MAAM,IAAI,aAAa,CAAC,gBAAgB,CAAC;gBAE/C,IAAI,GAAG,IAAI,CAAC;oBAAE,GAAG,GAAG,CAAC,CAAC;gBACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBAC5B,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;wBACf,KAAK;4BACL,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;iBAClE;aACF;SACF;IACH,CAAC;IAEO,aAAa;QACnB,MAAM,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;QAE9B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAC/B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,IAAI,EAAE,CAAC;QACf,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACK,eAAe,CACrB,GAAW,EACX,CAAS,EACT,CAAS,EACT,CAAS,EACT,CAAS,EACT,EAAU;QAEV,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;QACjB,IAAI,EAAE,GAAG,CAAC,CAAC;YAAE,EAAE,GAAG,CAAC,CAAC,CAAC;QAErB,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;QACjB,IAAI,EAAE,GAAG,IAAI,CAAC,YAAY;YAAE,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;QAEnD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACd,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACd,IAAI,CAAC,GAAG,CAAC,CAAC;QAEV,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE;YACvB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,aAAa,CAAC;YAC5D,IAAI,CAAC,GAAG,EAAE,EAAE;gBACV,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;gBAC7B,CAAC,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aACzE;YAED,IAAI,CAAC,GAAG,EAAE,EAAE;gBACV,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;gBAC7B,CAAC,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aACzE;SACF;IACH,CAAC;IAED;;OAEG;IACK,YAAY,CAClB,KAAa,EACb,CAAS,EACT,CAAS,EACT,CAAS,EACT,CAAS,EACT,CAAS;QAET,KAAK,IAAI,aAAa,CAAC,UAAU,CAAC;QAElC,sBAAsB;QACtB,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC3B,CAAC,CAAC,QAAQ,CACR,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EACjB,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EACjB,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EACjB,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAClB,CAAC;IACJ,CAAC;IAED;;;;;;;;;;OAUG;IACK,QAAQ,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,EAAU;QAC1D,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,gBAAgB,CAAC;QAEjD,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;QACvB,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC;QACjB,IAAI,WAAW,GAAG,OAAO,CAAC;QAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,EAAE;YAC1C,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,IAAI,GACR,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,UAAU,CAAC;YAEzE,IAAI,IAAI,GAAG,KAAK,EAAE;gBAChB,KAAK,GAAG,IAAI,CAAC;gBACb,OAAO,GAAG,CAAC,CAAC;aACb;YAED,MAAM,QAAQ,GACZ,IAAI;gBACJ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,iBAAiB,GAAG,gBAAgB,CAAC,CAAC,CAAC;YAC1E,IAAI,QAAQ,GAAG,SAAS,EAAE;gBACxB,SAAS,GAAG,QAAQ,CAAC;gBACrB,WAAW,GAAG,CAAC,CAAC;aACjB;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,aAAa,CAAC,UAAU,CAAC;YAC3D,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC;YAC1B,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,IAAI,aAAa,CAAC,WAAW,CAAC;SACxD;QACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,aAAa,CAAC,KAAK,CAAC;QAC3C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,aAAa,CAAC,UAAU,CAAC;QAChD,OAAO,WAAW,CAAC;IACrB,CAAC","sourcesContent":["/*\n * NeuQuantFloat Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass NeuronFloat {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n}\n\nexport class NeuQuantFloat extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuantFloat._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuantFloat._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta =\n    NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuantFloat._initialBias <<\n    (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuantFloat._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\n\n  private _pointArray!: Point[];\n  private readonly _networkSize!: number;\n  private _network!: NeuronFloat[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat(\n        (i << (networkBiasShift + 8)) / this._networkSize,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn(): IterableIterator<PaletteQuantizerYieldValue> {\n    let sampleFactor = this._sampleFactor;\n\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n\n    let delta = (pointsToSample / NeuQuantFloat._nCycles) | 0;\n    let alpha = NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\n\n    let rad = radius >> NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\n    }\n\n    let step;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\n      step = NeuQuantFloat._prime1;\n    } else if (pointsNumber % NeuQuantFloat._prime2 !== 0) {\n      step = NeuQuantFloat._prime2;\n    } else if (pointsNumber % NeuQuantFloat._prime3 !== 0) {\n      step = NeuQuantFloat._prime3;\n    } else {\n      step = NeuQuantFloat._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / NeuQuantFloat._radiusDecrease;\n        rad = radius >> NeuQuantFloat._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            alpha *\n            (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuantFloat._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, al: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuantFloat._beta;\n    this._bias[bestpos] -= NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n}\n"]}