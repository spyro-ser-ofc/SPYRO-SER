{"version":3,"file":"colorHistogram.js","sourceRoot":"","sources":["../../../../../src/palette/rgbquant/colorHistogram.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * ColorHistogram.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\nimport { HueStatistics } from '../../utils/hueStatistics';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { stableSort } from '../../utils/arithmetic';\n\ninterface Box {\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nexport class ColorHistogram {\n  private static _boxSize = [64, 64];\n  private static _boxPixels = 2;\n  private static _hueGroups = 10;\n\n  // 1 = by global population, 2 = subregion population threshold\n  private _method: number;\n\n  // HueStatistics instance\n  private _hueStats: HueStatistics;\n\n  private _histogram: { [color: string]: number };\n\n  // # of highest-frequency colors to start with for palette reduction\n  private _initColors: number;\n\n  // if > 0, enables hues stats and min-color retention per group\n  private _minHueCols: number;\n\n  constructor(method: number, colors: number) {\n    // 1 = by global population, 2 = subregion population threshold\n    this._method = method;\n\n    // if > 0, enables hues stats and min-color retention per group\n    this._minHueCols = colors << 2; // opts.minHueCols || 0;\n\n    // # of highest-frequency colors to start with for palette reduction\n    this._initColors = colors << 2;\n\n    // HueStatistics instance\n    this._hueStats = new HueStatistics(\n      ColorHistogram._hueGroups,\n      this._minHueCols,\n    );\n\n    this._histogram = Object.create(null); // tslint:disable-line:no-null-keyword\n  }\n\n  sample(pointContainer: PointContainer) {\n    // eslint-disable-next-line default-case\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n\n  getImportanceSortedColorsIDXI32() {\n    // TODO: fix typing issue in stableSort func\n    const sorted = stableSort(\n      Object.keys(this._histogram),\n      (a, b) => this._histogram[b] - this._histogram[a],\n    );\n    if (sorted.length === 0) {\n      return [];\n    }\n\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n\n        idxi32 = sorted.slice(0, initialColorsLimit);\n\n        // add any cut off colors with same freq as last\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n\n        // inject min huegroup colors\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n\n      case 2:\n        idxi32 = sorted;\n        break;\n\n      default:\n        // TODO: rethink errors\n        throw new Error('Incorrect method');\n    }\n\n    // int32-ify values\n    return idxi32.map((v) => +v);\n  }\n\n  // global top-population\n  private _colorStats1D(pointContainer: PointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n\n      // collect hue stats\n      this._hueStats.check(col);\n\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n\n  // population threshold within subregions\n  // FIXME: this can over-reduce (few/no colors same?), need a way to keep\n  // important colors that dont ever reach local thresholds (gradients?)\n  private _colorStats2D(pointContainer: PointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n\n    const boxW = ColorHistogram._boxSize[0];\n    const boxH = ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n\n    boxes.forEach((box) => {\n      let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\n      if (effc < 2) effc = 2;\n\n      const histL: Record<string, number> = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n\n        // collect hue stats\n        this._hueStats.check(col);\n\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n\n    // inject min huegroup colors\n    this._hueStats.injectIntoDictionary(histG);\n  }\n\n  // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n  private _iterateBox(bbox: Box, wid: number, fn: (i: number) => void) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n\n    let cnt = 0;\n    let i = i0;\n\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n\n  /**\n   *    partitions a rectangle of width x height into\n   *    array of boxes stepX x stepY (or less)\n   */\n  private _makeBoxes(\n    width: number,\n    height: number,\n    stepX: number,\n    stepY: number,\n  ) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n\n    for (let y = 0; y < height; y += stepY) {\n      for (let x = 0; x < width; x += stepX) {\n        boxesArray.push({\n          x,\n          y,\n          w: x === xend ? wrem : stepX,\n          h: y === yend ? hrem : stepY,\n        });\n      }\n    }\n\n    return boxesArray;\n  }\n}\n"]}