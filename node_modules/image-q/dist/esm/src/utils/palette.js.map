{"version":3,"file":"palette.js","sourceRoot":"","sources":["../../../../src/utils/palette.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { rgb2hsl } from '../conversion/rgb2hsl';\n\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\n\nconst hueGroups = 10;\n\nexport function hueGroup(hue: number, segmentsNumber: number) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg) return i;\n  }\n  return 0;\n}\n\nexport class Palette {\n  private readonly _pointContainer: PointContainer;\n  private readonly _pointArray: Point[] = [];\n  private _i32idx: { [key: string]: number } = {};\n\n  constructor() {\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n\n  add(color: Point) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n\n  has(color: Point) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32) return true;\n    }\n\n    return false;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\n  getNearestColor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    color: Point,\n  ) {\n    return this._pointArray[\n      this._getNearestIndex(colorDistanceCalculator, color) | 0\n    ];\n  }\n\n  getPointContainer() {\n    return this._pointContainer;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/\n  /*\n   public nearestIndexByUint32(i32) {\n   var idx : number = this._nearestPointFromCache(\"\" + i32);\n   if (idx >= 0) return idx;\n\n   var min = 1000,\n   rgb = [\n   (i32 & 0xff),\n   (i32 >>> 8) & 0xff,\n   (i32 >>> 16) & 0xff,\n   (i32 >>> 24) & 0xff\n   ],\n   len = this._pointArray.length;\n\n   idx = 0;\n   for (var i = 0; i < len; i++) {\n   var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\n\n   if (dist < min) {\n   min = dist;\n   idx = i;\n   }\n   }\n\n   this._i32idx[i32] = idx;\n   return idx;\n   }\n   */\n\n  private _nearestPointFromCache(key: string) {\n    return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;\n  }\n\n  private _getNearestIndex(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    point: Point,\n  ) {\n    let idx = this._nearestPointFromCache('' + point.uint32); // eslint-disable-line prefer-template\n    if (idx >= 0) return idx;\n\n    let minimalDistance = Number.MAX_VALUE;\n\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(\n        point.r,\n        point.g,\n        point.b,\n        point.a,\n        p.r,\n        p.g,\n        p.b,\n        p.a,\n      );\n\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n\n  /*\n   public reduce(histogram : ColorHistogram, colors : number) {\n   if (this._pointArray.length > colors) {\n   var idxi32 = histogram.getImportanceSortedColorsIDXI32();\n\n   // quantize histogram to existing palette\n   var keep = [], uniqueColors = 0, idx, pruned = false;\n\n   for (var i = 0, len = idxi32.length; i < len; i++) {\n   // palette length reached, unset all remaining colors (sparse palette)\n   if (uniqueColors >= colors) {\n   this.prunePal(keep);\n   pruned = true;\n   break;\n   } else {\n   idx = this.nearestIndexByUint32(idxi32[i]);\n   if (keep.indexOf(idx) < 0) {\n   keep.push(idx);\n   uniqueColors++;\n   }\n   }\n   }\n\n   if (!pruned) {\n   this.prunePal(keep);\n   }\n   }\n   }\n\n   // TODO: check usage, not tested!\n   public prunePal(keep : number[]) {\n   var colors = this._pointArray.length;\n   for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n   if (keep.indexOf(colorIndex) < 0) {\n\n   if(colorIndex + 1 < colors) {\n   this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\n   }\n   --colors;\n   //this._pointArray[colorIndex] = null;\n   }\n   }\n   console.log(\"colors pruned: \" + (this._pointArray.length - colors));\n   this._pointArray.length = colors;\n   this._i32idx = {};\n   }\n   */\n\n  // TODO: group very low lum and very high lum colors\n  // TODO: pass custom sort order\n  // TODO: sort criteria function should be placed to HueStats class\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a: Point, b: Point) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n\n      // sort all grays + whites together\n      const hueA =\n        a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB =\n        b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      /*\n       var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\n       var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\n       */\n\n      const hueDiff = hueB - hueA;\n      if (hueDiff) return -hueDiff;\n\n      /*\n       var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\n       if (lumDiff) return -lumDiff;\n       */\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n\n      if (lB - lA !== 0) return lB - lA;\n\n      const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\n      if (satDiff) return -satDiff;\n\n      return 0;\n    });\n  }\n}\n"]}