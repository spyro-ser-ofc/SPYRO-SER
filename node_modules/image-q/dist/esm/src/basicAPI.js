/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
import * as distance from './distance';
import * as image from './image';
import * as palette from './palette';
const setImmediateImpl = typeof setImmediate === 'function'
    ? setImmediate
    : typeof process !== 'undefined' && typeof process?.nextTick === 'function'
        ? (callback) => process.nextTick(callback)
        : (callback) => setTimeout(callback, 0);
export function buildPaletteSync(images, { colorDistanceFormula, paletteQuantization, colors, } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
    images.forEach((image) => paletteQuantizer.sample(image));
    return paletteQuantizer.quantizeSync();
}
export async function buildPalette(images, { colorDistanceFormula, paletteQuantization, colors, onProgress, } = {}) {
    return new Promise((resolve, reject) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
        images.forEach((image) => paletteQuantizer.sample(image));
        let palette;
        const iterator = paletteQuantizer.quantize();
        const next = () => {
            try {
                const result = iterator.next();
                if (result.done) {
                    resolve(palette);
                }
                else {
                    if (result.value.palette)
                        palette = result.value.palette;
                    if (onProgress)
                        onProgress(result.value.progress);
                    setImmediateImpl(next);
                }
            }
            catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    });
}
export function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
    return imageQuantizer.quantizeSync(image, palette);
}
export async function applyPalette(image, palette, { colorDistanceFormula, imageQuantization, onProgress, } = {}) {
    return new Promise((resolve, reject) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
        let outPointContainer;
        const iterator = imageQuantizer.quantize(image, palette);
        const next = () => {
            try {
                const result = iterator.next();
                if (result.done) {
                    resolve(outPointContainer);
                }
                else {
                    if (result.value.pointContainer) {
                        outPointContainer = result.value.pointContainer;
                    }
                    if (onProgress)
                        onProgress(result.value.progress);
                    setImmediateImpl(next);
                }
            }
            catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    });
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = 'euclidean-bt709') {
    switch (colorDistanceFormula) {
        case 'cie94-graphic-arts':
            return new distance.CIE94GraphicArts();
        case 'cie94-textiles':
            return new distance.CIE94Textiles();
        case 'ciede2000':
            return new distance.CIEDE2000();
        case 'color-metric':
            return new distance.CMetric();
        case 'euclidean':
            return new distance.Euclidean();
        case 'euclidean-bt709':
            return new distance.EuclideanBT709();
        case 'euclidean-bt709-noalpha':
            return new distance.EuclideanBT709NoAlpha();
        case 'manhattan':
            return new distance.Manhattan();
        case 'manhattan-bt709':
            return new distance.ManhattanBT709();
        case 'manhattan-nommyde':
            return new distance.ManhattanNommyde();
        case 'pngquant':
            return new distance.PNGQuant();
        default:
            throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = 'floyd-steinberg') {
    switch (imageQuantization) {
        case 'nearest':
            return new image.NearestColor(distanceCalculator);
        case 'riemersma':
            return new image.ErrorDiffusionRiemersma(distanceCalculator);
        case 'floyd-steinberg':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.FloydSteinberg);
        case 'false-floyd-steinberg':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.FalseFloydSteinberg);
        case 'stucki':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Stucki);
        case 'atkinson':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Atkinson);
        case 'jarvis':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Jarvis);
        case 'burkes':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Burkes);
        case 'sierra':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.Sierra);
        case 'two-sierra':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.TwoSierra);
        case 'sierra-lite':
            return new image.ErrorDiffusionArray(distanceCalculator, image.ErrorDiffusionArrayKernel.SierraLite);
        default:
            throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = 'wuquant', colors = 256) {
    switch (paletteQuantization) {
        case 'neuquant':
            return new palette.NeuQuant(distanceCalculator, colors);
        case 'rgbquant':
            return new palette.RGBQuant(distanceCalculator, colors);
        case 'wuquant':
            return new palette.WuQuant(distanceCalculator, colors);
        case 'neuquant-float':
            return new palette.NeuQuantFloat(distanceCalculator, colors);
        default:
            throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
}
//# sourceMappingURL=basicAPI.js.map